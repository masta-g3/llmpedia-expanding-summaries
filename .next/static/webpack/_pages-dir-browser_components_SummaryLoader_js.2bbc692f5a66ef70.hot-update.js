"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_SummaryLoader_js",{

/***/ "(pages-dir-browser)/./components/ExpandableSummary.js":
/*!*****************************************!*\
  !*** ./components/ExpandableSummary.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! marked */ \"(pages-dir-browser)/./node_modules/marked/lib/marked.esm.js\");\n/* harmony import */ var katex_dist_katex_min_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! katex/dist/katex.min.css */ \"(pages-dir-browser)/./node_modules/katex/dist/katex.min.css\");\n/* harmony import */ var katex_dist_katex_min_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(katex_dist_katex_min_css__WEBPACK_IMPORTED_MODULE_3__);\n\nvar _s = $RefreshSig$();\n\n\n\n// Custom renderer for LaTeX content\nconst customRenderer = {\n    // We'll use KaTeX's auto-render extension in the client-side\n    paragraph (text) {\n        return \"<p>\".concat(text, \"</p>\");\n    }\n};\nconst ExpandableSummary = (param)=>{\n    let { summary, expansionLevel } = param;\n    _s();\n    const [parsedContent, setParsedContent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [isTransitioning, setIsTransitioning] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Parse the content with original and new tags\n    const processContent = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ExpandableSummary.useMemo[processContent]\": ()=>{\n            console.log('Summary in ExpandableSummary:', summary);\n            // Make sure we have a string to work with\n            let summaryText = '';\n            if (typeof summary === 'string') {\n                summaryText = summary;\n            } else if (summary && typeof summary === 'object') {\n                console.log('Received an object instead of string. Object keys:', Object.keys(summary));\n                if (summary.paragraphs) {\n                    // Handle the case where summary is an array of paragraphs\n                    summaryText = Array.isArray(summary.paragraphs) ? summary.paragraphs.join('\\n\\n') : String(summary.paragraphs);\n                } else if (summary.text) {\n                    summaryText = summary.text;\n                } else {\n                    // Try to convert to JSON string\n                    try {\n                        summaryText = JSON.stringify(summary);\n                    } catch (e) {\n                        console.error('Failed to stringify summary object:', e);\n                        summaryText = \"Error processing summary data\";\n                    }\n                }\n            } else {\n                // Fallback for other types\n                summaryText = String(summary || '');\n                if (summaryText === '[object Object]') {\n                    summaryText = \"Error: Invalid summary format\";\n                }\n            }\n            console.log('Processed summaryText type:', typeof summaryText);\n            if (typeof summaryText === 'string') {\n                console.log('Processed summaryText sample:', summaryText.substring(0, 100) + '...');\n            }\n            // First check if the summary contains our expected tags\n            const hasTags = summaryText.includes('<original>') || summaryText.includes('<new>');\n            let processedSummary = summaryText;\n            if (hasTags) {\n                // Replace all <original> and <new> tags with spans that have appropriate classes\n                processedSummary = summaryText.replace(RegExp(\"<original>(.*?)<\\\\/original>\", \"gs\"), '<span class=\"original-content\">$1</span>').replace(RegExp(\"<new>(.*?)<\\\\/new>\", \"gs\"), '<span class=\"new-content\">$1</span>');\n            } else {\n                try {\n                    // Check if it's a JSON string but wasn't parsed earlier\n                    if (summaryText.trim().startsWith('{') || summaryText.trim().startsWith('[')) {\n                        try {\n                            const parsedSummary = JSON.parse(summaryText);\n                            if (Array.isArray(parsedSummary)) {\n                                // Join array items as paragraphs\n                                processedSummary = parsedSummary.join('\\n\\n');\n                            } else if (typeof parsedSummary === 'object' && parsedSummary.text) {\n                                processedSummary = parsedSummary.text;\n                            }\n                        } catch (e) {\n                            console.log('Failed to parse summary as JSON in component:', e);\n                        // Keep original if parsing fails\n                        }\n                    }\n                    // If the summary doesn't have tags, section it into paragraphs\n                    // Split by double newline to preserve paragraph structure\n                    const paragraphs = processedSummary.split(/\\n\\s*\\n/).filter({\n                        \"ExpandableSummary.useMemo[processContent].paragraphs\": (p)=>p.trim().length > 0\n                    }[\"ExpandableSummary.useMemo[processContent].paragraphs\"]);\n                    if (paragraphs.length > 0) {\n                        // Assign alternate classes to create visual separation\n                        processedSummary = paragraphs.map({\n                            \"ExpandableSummary.useMemo[processContent]\": (paragraph, index)=>{\n                                // For the slider to work, we need some content to be original and some to be new\n                                // Use the expansion level to determine how many paragraphs are \"original\" vs \"new\"\n                                const isOriginal = index < Math.ceil(paragraphs.length * 0.3); // First 30% paragraphs are original\n                                const className = isOriginal ? 'original-content' : 'new-content';\n                                return '<span class=\"'.concat(className, '\">').concat(paragraph, \"</span>\");\n                            }\n                        }[\"ExpandableSummary.useMemo[processContent]\"]).join('\\n\\n');\n                    } else {\n                        // If we couldn't split into paragraphs, just wrap everything\n                        processedSummary = '<span class=\"original-content\">'.concat(processedSummary, \"</span>\");\n                    }\n                } catch (error) {\n                    console.error('Error processing paragraphs:', error);\n                    // Fallback to wrapping everything as original\n                    processedSummary = '<span class=\"original-content\">'.concat(summaryText, \"</span>\");\n                }\n            }\n            // Convert markdown to HTML\n            return marked__WEBPACK_IMPORTED_MODULE_2__.marked.parse(processedSummary);\n        }\n    }[\"ExpandableSummary.useMemo[processContent]\"], [\n        summary\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ExpandableSummary.useEffect\": ()=>{\n            setParsedContent(processContent);\n        }\n    }[\"ExpandableSummary.useEffect\"], [\n        processContent\n    ]);\n    // Apply visibility based on the expansion level\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ExpandableSummary.useEffect\": ()=>{\n            if (typeof document !== 'undefined') {\n                setIsTransitioning(true);\n                // Small delay to ensure transitions are visible\n                const transitionDelay = setTimeout({\n                    \"ExpandableSummary.useEffect.transitionDelay\": ()=>{\n                        const newElements = document.querySelectorAll('.new-content');\n                        // Calculate how many elements should be visible based on the expansion level\n                        const totalNewElements = newElements.length;\n                        const visibleCount = Math.ceil(expansionLevel / 100 * totalNewElements);\n                        // Set visibility for each element\n                        newElements.forEach({\n                            \"ExpandableSummary.useEffect.transitionDelay\": (element, index)=>{\n                                if (index < visibleCount) {\n                                    element.style.opacity = '1';\n                                    element.style.display = 'inline';\n                                    // Add subtle highlight effect for newly visible content\n                                    element.style.backgroundColor = 'var(--new-color)';\n                                } else {\n                                    element.style.opacity = '0';\n                                    element.style.display = 'none';\n                                }\n                            }\n                        }[\"ExpandableSummary.useEffect.transitionDelay\"]);\n                        setIsTransitioning(false);\n                    }\n                }[\"ExpandableSummary.useEffect.transitionDelay\"], 50);\n                return ({\n                    \"ExpandableSummary.useEffect\": ()=>clearTimeout(transitionDelay)\n                })[\"ExpandableSummary.useEffect\"];\n            }\n        }\n    }[\"ExpandableSummary.useEffect\"], [\n        expansionLevel\n    ]);\n    // Configure marked.js with custom renderer\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ExpandableSummary.useEffect\": ()=>{\n            marked__WEBPACK_IMPORTED_MODULE_2__.marked.setOptions({\n                breaks: true,\n                gfm: true,\n                renderer: Object.assign(new marked__WEBPACK_IMPORTED_MODULE_2__.marked.Renderer(), customRenderer)\n            });\n        }\n    }[\"ExpandableSummary.useEffect\"], []);\n    // Handle LaTeX rendering on the client side only\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ExpandableSummary.useEffect\": ()=>{\n            if (true) {\n                // Instead of using KaTeX's auto-render, we'll handle LaTeX formatting in a simpler way\n                // for this lightweight application\n                const mathElements = document.querySelectorAll('.math');\n                mathElements.forEach({\n                    \"ExpandableSummary.useEffect\": (element)=>{\n                        if (element.textContent.includes('$')) {\n                            // Basic styling for math expressions\n                            element.style.fontFamily = 'serif';\n                            element.style.fontStyle = 'italic';\n                        }\n                    }\n                }[\"ExpandableSummary.useEffect\"]);\n            }\n        }\n    }[\"ExpandableSummary.useEffect\"], [\n        parsedContent\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"summary-content \".concat(isTransitioning ? 'fade-in' : ''),\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            dangerouslySetInnerHTML: {\n                __html: parsedContent\n            }\n        }, void 0, false, {\n            fileName: \"/Users/manager/Code/micro_apps/llmpedia-expanding-summaries/components/ExpandableSummary.js\",\n            lineNumber: 182,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/manager/Code/micro_apps/llmpedia-expanding-summaries/components/ExpandableSummary.js\",\n        lineNumber: 181,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ExpandableSummary, \"Tjj1capCXCjfB4bJ4jbMGFYb/yc=\");\n_c = ExpandableSummary;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExpandableSummary);\nvar _c;\n$RefreshReg$(_c, \"ExpandableSummary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvRXhwYW5kYWJsZVN1bW1hcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFxRDtBQUNyQjtBQUNFO0FBRWxDLG9DQUFvQztBQUNwQyxNQUFNSSxpQkFBaUI7SUFDckIsNkRBQTZEO0lBQzdEQyxXQUFVQyxJQUFJO1FBQ1osT0FBTyxNQUFXLE9BQUxBLE1BQUs7SUFDcEI7QUFDRjtBQUVBLE1BQU1DLG9CQUFvQjtRQUFDLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFOztJQUNwRCxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHWCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNZLGlCQUFpQkMsbUJBQW1CLEdBQUdiLCtDQUFRQSxDQUFDO0lBRXZELCtDQUErQztJQUMvQyxNQUFNYyxpQkFBaUJaLDhDQUFPQTtxREFBQztZQUM3QmEsUUFBUUMsR0FBRyxDQUFDLGlDQUFpQ1I7WUFFN0MsMENBQTBDO1lBQzFDLElBQUlTLGNBQWM7WUFFbEIsSUFBSSxPQUFPVCxZQUFZLFVBQVU7Z0JBQy9CUyxjQUFjVDtZQUNoQixPQUFPLElBQUlBLFdBQVcsT0FBT0EsWUFBWSxVQUFVO2dCQUNqRE8sUUFBUUMsR0FBRyxDQUFDLHNEQUFzREUsT0FBT0MsSUFBSSxDQUFDWDtnQkFFOUUsSUFBSUEsUUFBUVksVUFBVSxFQUFFO29CQUN0QiwwREFBMEQ7b0JBQzFESCxjQUFjSSxNQUFNQyxPQUFPLENBQUNkLFFBQVFZLFVBQVUsSUFDMUNaLFFBQVFZLFVBQVUsQ0FBQ0csSUFBSSxDQUFDLFVBQ3hCQyxPQUFPaEIsUUFBUVksVUFBVTtnQkFDL0IsT0FBTyxJQUFJWixRQUFRRixJQUFJLEVBQUU7b0JBQ3ZCVyxjQUFjVCxRQUFRRixJQUFJO2dCQUM1QixPQUFPO29CQUNMLGdDQUFnQztvQkFDaEMsSUFBSTt3QkFDRlcsY0FBY1EsS0FBS0MsU0FBUyxDQUFDbEI7b0JBQy9CLEVBQUUsT0FBT21CLEdBQUc7d0JBQ1ZaLFFBQVFhLEtBQUssQ0FBQyx1Q0FBdUNEO3dCQUNyRFYsY0FBYztvQkFDaEI7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMLDJCQUEyQjtnQkFDM0JBLGNBQWNPLE9BQU9oQixXQUFXO2dCQUNoQyxJQUFJUyxnQkFBZ0IsbUJBQW1CO29CQUNyQ0EsY0FBYztnQkFDaEI7WUFDRjtZQUVBRixRQUFRQyxHQUFHLENBQUMsK0JBQStCLE9BQU9DO1lBQ2xELElBQUksT0FBT0EsZ0JBQWdCLFVBQVU7Z0JBQ25DRixRQUFRQyxHQUFHLENBQUMsaUNBQWlDQyxZQUFZWSxTQUFTLENBQUMsR0FBRyxPQUFPO1lBQy9FO1lBRUEsd0RBQXdEO1lBQ3hELE1BQU1DLFVBQVViLFlBQVljLFFBQVEsQ0FBQyxpQkFBaUJkLFlBQVljLFFBQVEsQ0FBQztZQUUzRSxJQUFJQyxtQkFBbUJmO1lBRXZCLElBQUlhLFNBQVM7Z0JBQ1gsaUZBQWlGO2dCQUNqRkUsbUJBQW1CZixZQUFZZ0IsT0FBTyxDQUNwQyw4Q0FDQSw0Q0FDQUEsT0FBTyxDQUNQLG9DQUNBO1lBRUosT0FBTztnQkFDTCxJQUFJO29CQUNGLHdEQUF3RDtvQkFDeEQsSUFBSWhCLFlBQVlpQixJQUFJLEdBQUdDLFVBQVUsQ0FBQyxRQUFRbEIsWUFBWWlCLElBQUksR0FBR0MsVUFBVSxDQUFDLE1BQU07d0JBQzVFLElBQUk7NEJBQ0YsTUFBTUMsZ0JBQWdCWCxLQUFLWSxLQUFLLENBQUNwQjs0QkFDakMsSUFBSUksTUFBTUMsT0FBTyxDQUFDYyxnQkFBZ0I7Z0NBQ2hDLGlDQUFpQztnQ0FDakNKLG1CQUFtQkksY0FBY2IsSUFBSSxDQUFDOzRCQUN4QyxPQUFPLElBQUksT0FBT2Esa0JBQWtCLFlBQVlBLGNBQWM5QixJQUFJLEVBQUU7Z0NBQ2xFMEIsbUJBQW1CSSxjQUFjOUIsSUFBSTs0QkFDdkM7d0JBQ0YsRUFBRSxPQUFPcUIsR0FBRzs0QkFDVlosUUFBUUMsR0FBRyxDQUFDLGlEQUFpRFc7d0JBQzdELGlDQUFpQzt3QkFDbkM7b0JBQ0Y7b0JBRUEsK0RBQStEO29CQUMvRCwwREFBMEQ7b0JBQzFELE1BQU1QLGFBQWFZLGlCQUFpQk0sS0FBSyxDQUFDLFdBQVdDLE1BQU07Z0ZBQUNDLENBQUFBLElBQUtBLEVBQUVOLElBQUksR0FBR08sTUFBTSxHQUFHOztvQkFFbkYsSUFBSXJCLFdBQVdxQixNQUFNLEdBQUcsR0FBRzt3QkFDekIsdURBQXVEO3dCQUN2RFQsbUJBQW1CWixXQUFXc0IsR0FBRzt5RUFBQyxDQUFDckMsV0FBV3NDO2dDQUM1QyxpRkFBaUY7Z0NBQ2pGLG1GQUFtRjtnQ0FDbkYsTUFBTUMsYUFBYUQsUUFBUUUsS0FBS0MsSUFBSSxDQUFDMUIsV0FBV3FCLE1BQU0sR0FBRyxNQUFNLG9DQUFvQztnQ0FDbkcsTUFBTU0sWUFBWUgsYUFBYSxxQkFBcUI7Z0NBQ3BELE9BQU8sZ0JBQThCdkMsT0FBZDBDLFdBQVUsTUFBYyxPQUFWMUMsV0FBVTs0QkFDakQ7d0VBQUdrQixJQUFJLENBQUM7b0JBQ1YsT0FBTzt3QkFDTCw2REFBNkQ7d0JBQzdEUyxtQkFBbUIsa0NBQW1ELE9BQWpCQSxrQkFBaUI7b0JBQ3hFO2dCQUNGLEVBQUUsT0FBT0osT0FBTztvQkFDZGIsUUFBUWEsS0FBSyxDQUFDLGdDQUFnQ0E7b0JBQzlDLDhDQUE4QztvQkFDOUNJLG1CQUFtQixrQ0FBOEMsT0FBWmYsYUFBWTtnQkFDbkU7WUFDRjtZQUVBLDJCQUEyQjtZQUMzQixPQUFPZCwwQ0FBTUEsQ0FBQ2tDLEtBQUssQ0FBQ0w7UUFDdEI7b0RBQUc7UUFBQ3hCO0tBQVE7SUFFWlAsZ0RBQVNBO3VDQUFDO1lBQ1JVLGlCQUFpQkc7UUFDbkI7c0NBQUc7UUFBQ0E7S0FBZTtJQUVuQixnREFBZ0Q7SUFDaERiLGdEQUFTQTt1Q0FBQztZQUNSLElBQUksT0FBTytDLGFBQWEsYUFBYTtnQkFDbkNuQyxtQkFBbUI7Z0JBRW5CLGdEQUFnRDtnQkFDaEQsTUFBTW9DLGtCQUFrQkM7bUVBQVc7d0JBQ2pDLE1BQU1DLGNBQWNILFNBQVNJLGdCQUFnQixDQUFDO3dCQUU5Qyw2RUFBNkU7d0JBQzdFLE1BQU1DLG1CQUFtQkYsWUFBWVYsTUFBTTt3QkFDM0MsTUFBTWEsZUFBZVQsS0FBS0MsSUFBSSxDQUFDLGlCQUFrQixNQUFPTzt3QkFFeEQsa0NBQWtDO3dCQUNsQ0YsWUFBWUksT0FBTzsyRUFBQyxDQUFDQyxTQUFTYjtnQ0FDNUIsSUFBSUEsUUFBUVcsY0FBYztvQ0FDeEJFLFFBQVFDLEtBQUssQ0FBQ0MsT0FBTyxHQUFHO29DQUN4QkYsUUFBUUMsS0FBSyxDQUFDRSxPQUFPLEdBQUc7b0NBQ3hCLHdEQUF3RDtvQ0FDeERILFFBQVFDLEtBQUssQ0FBQ0csZUFBZSxHQUFHO2dDQUNsQyxPQUFPO29DQUNMSixRQUFRQyxLQUFLLENBQUNDLE9BQU8sR0FBRztvQ0FDeEJGLFFBQVFDLEtBQUssQ0FBQ0UsT0FBTyxHQUFHO2dDQUMxQjs0QkFDRjs7d0JBRUE5QyxtQkFBbUI7b0JBQ3JCO2tFQUFHO2dCQUVIO21EQUFPLElBQU1nRCxhQUFhWjs7WUFDNUI7UUFDRjtzQ0FBRztRQUFDeEM7S0FBZTtJQUVuQiwyQ0FBMkM7SUFDM0NSLGdEQUFTQTt1Q0FBQztZQUNSRSwwQ0FBTUEsQ0FBQzJELFVBQVUsQ0FBQztnQkFDaEJDLFFBQVE7Z0JBQ1JDLEtBQUs7Z0JBQ0xDLFVBQVUvQyxPQUFPZ0QsTUFBTSxDQUFDLElBQUkvRCwwQ0FBTUEsQ0FBQ2dFLFFBQVEsSUFBSS9EO1lBQ2pEO1FBQ0Y7c0NBQUcsRUFBRTtJQUVMLGlEQUFpRDtJQUNqREgsZ0RBQVNBO3VDQUFDO1lBQ1IsSUFBSSxJQUE2QixFQUFFO2dCQUNqQyx1RkFBdUY7Z0JBQ3ZGLG1DQUFtQztnQkFDbkMsTUFBTW1FLGVBQWVwQixTQUFTSSxnQkFBZ0IsQ0FBQztnQkFDL0NnQixhQUFhYixPQUFPO21EQUFDQyxDQUFBQTt3QkFDbkIsSUFBSUEsUUFBUWEsV0FBVyxDQUFDdEMsUUFBUSxDQUFDLE1BQU07NEJBQ3JDLHFDQUFxQzs0QkFDckN5QixRQUFRQyxLQUFLLENBQUNhLFVBQVUsR0FBRzs0QkFDM0JkLFFBQVFDLEtBQUssQ0FBQ2MsU0FBUyxHQUFHO3dCQUM1QjtvQkFDRjs7WUFDRjtRQUNGO3NDQUFHO1FBQUM3RDtLQUFjO0lBRWxCLHFCQUNFLDhEQUFDOEQ7UUFBSXpCLFdBQVcsbUJBQW9ELE9BQWpDbkMsa0JBQWtCLFlBQVk7a0JBQy9ELDRFQUFDNEQ7WUFDQ0MseUJBQXlCO2dCQUFFQyxRQUFRaEU7WUFBYzs7Ozs7Ozs7Ozs7QUFJekQ7R0E5S01IO0tBQUFBO0FBZ0xOLGlFQUFlQSxpQkFBaUJBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYW5hZ2VyL0NvZGUvbWljcm9fYXBwcy9sbG1wZWRpYS1leHBhbmRpbmctc3VtbWFyaWVzL2NvbXBvbmVudHMvRXhwYW5kYWJsZVN1bW1hcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG1hcmtlZCB9IGZyb20gJ21hcmtlZCc7XG5pbXBvcnQgJ2thdGV4L2Rpc3Qva2F0ZXgubWluLmNzcyc7XG5cbi8vIEN1c3RvbSByZW5kZXJlciBmb3IgTGFUZVggY29udGVudFxuY29uc3QgY3VzdG9tUmVuZGVyZXIgPSB7XG4gIC8vIFdlJ2xsIHVzZSBLYVRlWCdzIGF1dG8tcmVuZGVyIGV4dGVuc2lvbiBpbiB0aGUgY2xpZW50LXNpZGVcbiAgcGFyYWdyYXBoKHRleHQpIHtcbiAgICByZXR1cm4gYDxwPiR7dGV4dH08L3A+YDtcbiAgfVxufTtcblxuY29uc3QgRXhwYW5kYWJsZVN1bW1hcnkgPSAoeyBzdW1tYXJ5LCBleHBhbnNpb25MZXZlbCB9KSA9PiB7XG4gIGNvbnN0IFtwYXJzZWRDb250ZW50LCBzZXRQYXJzZWRDb250ZW50XSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW2lzVHJhbnNpdGlvbmluZywgc2V0SXNUcmFuc2l0aW9uaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgXG4gIC8vIFBhcnNlIHRoZSBjb250ZW50IHdpdGggb3JpZ2luYWwgYW5kIG5ldyB0YWdzXG4gIGNvbnN0IHByb2Nlc3NDb250ZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1N1bW1hcnkgaW4gRXhwYW5kYWJsZVN1bW1hcnk6Jywgc3VtbWFyeSk7XG4gICAgXG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBzdHJpbmcgdG8gd29yayB3aXRoXG4gICAgbGV0IHN1bW1hcnlUZXh0ID0gJyc7XG4gICAgXG4gICAgaWYgKHR5cGVvZiBzdW1tYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgc3VtbWFyeVRleHQgPSBzdW1tYXJ5O1xuICAgIH0gZWxzZSBpZiAoc3VtbWFyeSAmJiB0eXBlb2Ygc3VtbWFyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBhbiBvYmplY3QgaW5zdGVhZCBvZiBzdHJpbmcuIE9iamVjdCBrZXlzOicsIE9iamVjdC5rZXlzKHN1bW1hcnkpKTtcbiAgICAgIFxuICAgICAgaWYgKHN1bW1hcnkucGFyYWdyYXBocykge1xuICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgc3VtbWFyeSBpcyBhbiBhcnJheSBvZiBwYXJhZ3JhcGhzXG4gICAgICAgIHN1bW1hcnlUZXh0ID0gQXJyYXkuaXNBcnJheShzdW1tYXJ5LnBhcmFncmFwaHMpIFxuICAgICAgICAgID8gc3VtbWFyeS5wYXJhZ3JhcGhzLmpvaW4oJ1xcblxcbicpXG4gICAgICAgICAgOiBTdHJpbmcoc3VtbWFyeS5wYXJhZ3JhcGhzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VtbWFyeS50ZXh0KSB7XG4gICAgICAgIHN1bW1hcnlUZXh0ID0gc3VtbWFyeS50ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHJ5IHRvIGNvbnZlcnQgdG8gSlNPTiBzdHJpbmdcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdW1tYXJ5VGV4dCA9IEpTT04uc3RyaW5naWZ5KHN1bW1hcnkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHN0cmluZ2lmeSBzdW1tYXJ5IG9iamVjdDonLCBlKTtcbiAgICAgICAgICBzdW1tYXJ5VGV4dCA9IFwiRXJyb3IgcHJvY2Vzc2luZyBzdW1tYXJ5IGRhdGFcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayBmb3Igb3RoZXIgdHlwZXNcbiAgICAgIHN1bW1hcnlUZXh0ID0gU3RyaW5nKHN1bW1hcnkgfHwgJycpO1xuICAgICAgaWYgKHN1bW1hcnlUZXh0ID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICBzdW1tYXJ5VGV4dCA9IFwiRXJyb3I6IEludmFsaWQgc3VtbWFyeSBmb3JtYXRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1Byb2Nlc3NlZCBzdW1tYXJ5VGV4dCB0eXBlOicsIHR5cGVvZiBzdW1tYXJ5VGV4dCk7XG4gICAgaWYgKHR5cGVvZiBzdW1tYXJ5VGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzZWQgc3VtbWFyeVRleHQgc2FtcGxlOicsIHN1bW1hcnlUZXh0LnN1YnN0cmluZygwLCAxMDApICsgJy4uLicpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGUgc3VtbWFyeSBjb250YWlucyBvdXIgZXhwZWN0ZWQgdGFnc1xuICAgIGNvbnN0IGhhc1RhZ3MgPSBzdW1tYXJ5VGV4dC5pbmNsdWRlcygnPG9yaWdpbmFsPicpIHx8IHN1bW1hcnlUZXh0LmluY2x1ZGVzKCc8bmV3PicpO1xuICAgIFxuICAgIGxldCBwcm9jZXNzZWRTdW1tYXJ5ID0gc3VtbWFyeVRleHQ7XG4gICAgXG4gICAgaWYgKGhhc1RhZ3MpIHtcbiAgICAgIC8vIFJlcGxhY2UgYWxsIDxvcmlnaW5hbD4gYW5kIDxuZXc+IHRhZ3Mgd2l0aCBzcGFucyB0aGF0IGhhdmUgYXBwcm9wcmlhdGUgY2xhc3Nlc1xuICAgICAgcHJvY2Vzc2VkU3VtbWFyeSA9IHN1bW1hcnlUZXh0LnJlcGxhY2UoXG4gICAgICAgIC88b3JpZ2luYWw+KC4qPyk8XFwvb3JpZ2luYWw+L2dzLCBcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwib3JpZ2luYWwtY29udGVudFwiPiQxPC9zcGFuPidcbiAgICAgICkucmVwbGFjZShcbiAgICAgICAgLzxuZXc+KC4qPyk8XFwvbmV3Pi9ncywgXG4gICAgICAgICc8c3BhbiBjbGFzcz1cIm5ldy1jb250ZW50XCI+JDE8L3NwYW4+J1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIEpTT04gc3RyaW5nIGJ1dCB3YXNuJ3QgcGFyc2VkIGVhcmxpZXJcbiAgICAgICAgaWYgKHN1bW1hcnlUZXh0LnRyaW0oKS5zdGFydHNXaXRoKCd7JykgfHwgc3VtbWFyeVRleHQudHJpbSgpLnN0YXJ0c1dpdGgoJ1snKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTdW1tYXJ5ID0gSlNPTi5wYXJzZShzdW1tYXJ5VGV4dCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRTdW1tYXJ5KSkge1xuICAgICAgICAgICAgICAvLyBKb2luIGFycmF5IGl0ZW1zIGFzIHBhcmFncmFwaHNcbiAgICAgICAgICAgICAgcHJvY2Vzc2VkU3VtbWFyeSA9IHBhcnNlZFN1bW1hcnkuam9pbignXFxuXFxuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJzZWRTdW1tYXJ5ID09PSAnb2JqZWN0JyAmJiBwYXJzZWRTdW1tYXJ5LnRleHQpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc2VkU3VtbWFyeSA9IHBhcnNlZFN1bW1hcnkudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIHBhcnNlIHN1bW1hcnkgYXMgSlNPTiBpbiBjb21wb25lbnQ6JywgZSk7XG4gICAgICAgICAgICAvLyBLZWVwIG9yaWdpbmFsIGlmIHBhcnNpbmcgZmFpbHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoZSBzdW1tYXJ5IGRvZXNuJ3QgaGF2ZSB0YWdzLCBzZWN0aW9uIGl0IGludG8gcGFyYWdyYXBoc1xuICAgICAgICAvLyBTcGxpdCBieSBkb3VibGUgbmV3bGluZSB0byBwcmVzZXJ2ZSBwYXJhZ3JhcGggc3RydWN0dXJlXG4gICAgICAgIGNvbnN0IHBhcmFncmFwaHMgPSBwcm9jZXNzZWRTdW1tYXJ5LnNwbGl0KC9cXG5cXHMqXFxuLykuZmlsdGVyKHAgPT4gcC50cmltKCkubGVuZ3RoID4gMCk7XG4gICAgICAgIFxuICAgICAgICBpZiAocGFyYWdyYXBocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gQXNzaWduIGFsdGVybmF0ZSBjbGFzc2VzIHRvIGNyZWF0ZSB2aXN1YWwgc2VwYXJhdGlvblxuICAgICAgICAgIHByb2Nlc3NlZFN1bW1hcnkgPSBwYXJhZ3JhcGhzLm1hcCgocGFyYWdyYXBoLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgLy8gRm9yIHRoZSBzbGlkZXIgdG8gd29yaywgd2UgbmVlZCBzb21lIGNvbnRlbnQgdG8gYmUgb3JpZ2luYWwgYW5kIHNvbWUgdG8gYmUgbmV3XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGV4cGFuc2lvbiBsZXZlbCB0byBkZXRlcm1pbmUgaG93IG1hbnkgcGFyYWdyYXBocyBhcmUgXCJvcmlnaW5hbFwiIHZzIFwibmV3XCJcbiAgICAgICAgICAgIGNvbnN0IGlzT3JpZ2luYWwgPSBpbmRleCA8IE1hdGguY2VpbChwYXJhZ3JhcGhzLmxlbmd0aCAqIDAuMyk7IC8vIEZpcnN0IDMwJSBwYXJhZ3JhcGhzIGFyZSBvcmlnaW5hbFxuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gaXNPcmlnaW5hbCA/ICdvcmlnaW5hbC1jb250ZW50JyA6ICduZXctY29udGVudCc7XG4gICAgICAgICAgICByZXR1cm4gYDxzcGFuIGNsYXNzPVwiJHtjbGFzc05hbWV9XCI+JHtwYXJhZ3JhcGh9PC9zcGFuPmA7XG4gICAgICAgICAgfSkuam9pbignXFxuXFxuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgd2UgY291bGRuJ3Qgc3BsaXQgaW50byBwYXJhZ3JhcGhzLCBqdXN0IHdyYXAgZXZlcnl0aGluZ1xuICAgICAgICAgIHByb2Nlc3NlZFN1bW1hcnkgPSBgPHNwYW4gY2xhc3M9XCJvcmlnaW5hbC1jb250ZW50XCI+JHtwcm9jZXNzZWRTdW1tYXJ5fTwvc3Bhbj5gO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIHBhcmFncmFwaHM6JywgZXJyb3IpO1xuICAgICAgICAvLyBGYWxsYmFjayB0byB3cmFwcGluZyBldmVyeXRoaW5nIGFzIG9yaWdpbmFsXG4gICAgICAgIHByb2Nlc3NlZFN1bW1hcnkgPSBgPHNwYW4gY2xhc3M9XCJvcmlnaW5hbC1jb250ZW50XCI+JHtzdW1tYXJ5VGV4dH08L3NwYW4+YDtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ29udmVydCBtYXJrZG93biB0byBIVE1MXG4gICAgcmV0dXJuIG1hcmtlZC5wYXJzZShwcm9jZXNzZWRTdW1tYXJ5KTtcbiAgfSwgW3N1bW1hcnldKTtcbiAgXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0UGFyc2VkQ29udGVudChwcm9jZXNzQ29udGVudCk7XG4gIH0sIFtwcm9jZXNzQ29udGVudF0pO1xuICBcbiAgLy8gQXBwbHkgdmlzaWJpbGl0eSBiYXNlZCBvbiB0aGUgZXhwYW5zaW9uIGxldmVsXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNldElzVHJhbnNpdGlvbmluZyh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIHRyYW5zaXRpb25zIGFyZSB2aXNpYmxlXG4gICAgICBjb25zdCB0cmFuc2l0aW9uRGVsYXkgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3RWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubmV3LWNvbnRlbnQnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBob3cgbWFueSBlbGVtZW50cyBzaG91bGQgYmUgdmlzaWJsZSBiYXNlZCBvbiB0aGUgZXhwYW5zaW9uIGxldmVsXG4gICAgICAgIGNvbnN0IHRvdGFsTmV3RWxlbWVudHMgPSBuZXdFbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHZpc2libGVDb3VudCA9IE1hdGguY2VpbCgoZXhwYW5zaW9uTGV2ZWwgLyAxMDApICogdG90YWxOZXdFbGVtZW50cyk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgdmlzaWJpbGl0eSBmb3IgZWFjaCBlbGVtZW50XG4gICAgICAgIG5ld0VsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGluZGV4IDwgdmlzaWJsZUNvdW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgICAgIC8vIEFkZCBzdWJ0bGUgaGlnaGxpZ2h0IGVmZmVjdCBmb3IgbmV3bHkgdmlzaWJsZSBjb250ZW50XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd2YXIoLS1uZXctY29sb3IpJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBzZXRJc1RyYW5zaXRpb25pbmcoZmFsc2UpO1xuICAgICAgfSwgNTApO1xuICAgICAgXG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRyYW5zaXRpb25EZWxheSk7XG4gICAgfVxuICB9LCBbZXhwYW5zaW9uTGV2ZWxdKTtcbiAgXG4gIC8vIENvbmZpZ3VyZSBtYXJrZWQuanMgd2l0aCBjdXN0b20gcmVuZGVyZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBtYXJrZWQuc2V0T3B0aW9ucyh7XG4gICAgICBicmVha3M6IHRydWUsXG4gICAgICBnZm06IHRydWUsXG4gICAgICByZW5kZXJlcjogT2JqZWN0LmFzc2lnbihuZXcgbWFya2VkLlJlbmRlcmVyKCksIGN1c3RvbVJlbmRlcmVyKVxuICAgIH0pO1xuICB9LCBbXSk7XG4gIFxuICAvLyBIYW5kbGUgTGFUZVggcmVuZGVyaW5nIG9uIHRoZSBjbGllbnQgc2lkZSBvbmx5XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJbnN0ZWFkIG9mIHVzaW5nIEthVGVYJ3MgYXV0by1yZW5kZXIsIHdlJ2xsIGhhbmRsZSBMYVRlWCBmb3JtYXR0aW5nIGluIGEgc2ltcGxlciB3YXlcbiAgICAgIC8vIGZvciB0aGlzIGxpZ2h0d2VpZ2h0IGFwcGxpY2F0aW9uXG4gICAgICBjb25zdCBtYXRoRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubWF0aCcpO1xuICAgICAgbWF0aEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50LnRleHRDb250ZW50LmluY2x1ZGVzKCckJykpIHtcbiAgICAgICAgICAvLyBCYXNpYyBzdHlsaW5nIGZvciBtYXRoIGV4cHJlc3Npb25zXG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5mb250RmFtaWx5ID0gJ3NlcmlmJztcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLmZvbnRTdHlsZSA9ICdpdGFsaWMnO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtwYXJzZWRDb250ZW50XSk7XG4gIFxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtgc3VtbWFyeS1jb250ZW50ICR7aXNUcmFuc2l0aW9uaW5nID8gJ2ZhZGUtaW4nIDogJyd9YH0+XG4gICAgICA8ZGl2IFxuICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IHBhcnNlZENvbnRlbnQgfX0gXG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRXhwYW5kYWJsZVN1bW1hcnk7Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsIm1hcmtlZCIsImN1c3RvbVJlbmRlcmVyIiwicGFyYWdyYXBoIiwidGV4dCIsIkV4cGFuZGFibGVTdW1tYXJ5Iiwic3VtbWFyeSIsImV4cGFuc2lvbkxldmVsIiwicGFyc2VkQ29udGVudCIsInNldFBhcnNlZENvbnRlbnQiLCJpc1RyYW5zaXRpb25pbmciLCJzZXRJc1RyYW5zaXRpb25pbmciLCJwcm9jZXNzQ29udGVudCIsImNvbnNvbGUiLCJsb2ciLCJzdW1tYXJ5VGV4dCIsIk9iamVjdCIsImtleXMiLCJwYXJhZ3JhcGhzIiwiQXJyYXkiLCJpc0FycmF5Iiwiam9pbiIsIlN0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwiZXJyb3IiLCJzdWJzdHJpbmciLCJoYXNUYWdzIiwiaW5jbHVkZXMiLCJwcm9jZXNzZWRTdW1tYXJ5IiwicmVwbGFjZSIsInRyaW0iLCJzdGFydHNXaXRoIiwicGFyc2VkU3VtbWFyeSIsInBhcnNlIiwic3BsaXQiLCJmaWx0ZXIiLCJwIiwibGVuZ3RoIiwibWFwIiwiaW5kZXgiLCJpc09yaWdpbmFsIiwiTWF0aCIsImNlaWwiLCJjbGFzc05hbWUiLCJkb2N1bWVudCIsInRyYW5zaXRpb25EZWxheSIsInNldFRpbWVvdXQiLCJuZXdFbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ0b3RhbE5ld0VsZW1lbnRzIiwidmlzaWJsZUNvdW50IiwiZm9yRWFjaCIsImVsZW1lbnQiLCJzdHlsZSIsIm9wYWNpdHkiLCJkaXNwbGF5IiwiYmFja2dyb3VuZENvbG9yIiwiY2xlYXJUaW1lb3V0Iiwic2V0T3B0aW9ucyIsImJyZWFrcyIsImdmbSIsInJlbmRlcmVyIiwiYXNzaWduIiwiUmVuZGVyZXIiLCJtYXRoRWxlbWVudHMiLCJ0ZXh0Q29udGVudCIsImZvbnRGYW1pbHkiLCJmb250U3R5bGUiLCJkaXYiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/ExpandableSummary.js\n"));

/***/ })

});